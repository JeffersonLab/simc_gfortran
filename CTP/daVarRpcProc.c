/*-----------------------------------------------------------------------------
 * Copyright (c) 1993 Southeastern Universities Research Association,
 *                    Continuous Electron Beam Accelerator Facility
 *
 * This software was developed under a United States Government license
 * described in the NOTICE file included as part of this distribution.
 *
 * Stephen A. Wood, 12000 Jefferson Ave., Newport News, VA 23606
 * Email: saw@cebaf.gov  Tel: (804) 249-7367  Fax: (804) 249-5800
 *-----------------------------------------------------------------------------
 * 
 * Description:
 *  RPC server interface routines.
 *  Actual rpc routines on the server side.  These routines repackage
 *  the rpc argument and call the real server routines.
 *
 * Author:  Stephen Wood, CEBAF Hall C
 *
 * Revision History:
 *   $Log: daVarRpcProc.c,v $
 *   Revision 1.1  2009/01/23 13:34:01  gaskelld
 *   Initial revision
 *
 *   Revision 1.2.22.1  2008/09/25 00:54:05  jones
 *   Updated for running on Fedora 8 with gfortran
 *
 *   Revision 1.3  2008/09/25 00:01:29  jones
 *   Updated to run with gfortran compiler
 *
 *   Revision 1.2.24.1  2007/09/10 21:32:47  pcarter
 *   Implemented changes to allow compilation on RHEL 3,4,5 and MacOSX
 *
 *   Revision 1.2  1999/11/04 20:34:04  saw
 *   Alpha compatibility.
 *   New RPC call needed for root event display.
 *   Start of code to write ROOT trees (ntuples) from new "tree" block
 *
 *   Revision 1.5  1999/08/25 13:16:05  saw
 *   *** empty log message ***
 *
 *   Revision 1.4  1999/03/01 19:52:30  saw
 *   Need svc_soc.h on sun
 *
 *   Revision 1.3  1994/11/07 14:15:46  saw
 *   Add davar_readmultiple_test_1
 *   Add Callback routine
 *   On HP, replace broken xdr_free's with my own freeing
 *
 *	  Revision 1.2  1993/12/03  19:30:58  saw
 *	  Remove some miscelaneous print statements
 *
 *	  Revision 1.1  1993/05/10  21:14:59  saw
 *	  Initial revision
 *
 */

#include <stdio.h>
#include <rpc/rpc.h>		/* always need this here */
#ifdef __sun
#include <rpc/svc_soc.h>
#endif
#include <limits.h>
#include "daVarRpc.h"		/* need this too: generated by rpcgen */
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <time.h>

#include "cfortran.h"
#include "daVar.h"
#include "daVarHandlers.h"

#ifdef hpux
#define xdr_on_hp_is_broken
#endif

int daVarCallBack();
FCALLSCFUN0(INT,daVarCallBack,THCALLBACK,thcallback);


static struct timeval TIMEOUT = { 5, 0}; /* Allow 5 seconds for timeout */
/*
 * Remote verson of "ackmessage"
 */
int *nullproc_1(int *argp, CLIENT *clnt)
{
  static int result;

  result = 0;

	return(&result);
}
/*
 * Remote verson of "ackmessage"
 */
int * 
davar_ackmessage_1(char **argp, CLIENT *clnt)
{

	static int  result;

/*	printf("Ack: %s\n",*argp);*/
	result = strlen(*argp);

	return(&result);
}

int *
davar_ackmessage_1_svc(char **argp, struct svc_req *svc)
{
	CLIENT *clnt;
	return(davar_ackmessage_1(argp,clnt));
}

NAMELIST * 
davar_getlist_1(char **argp, CLIENT *clnt)
{

	static NAMELIST result={0,0};
	char **list;
	int i, count;

	if(result.NAMELIST_val){
/*	  printf("Freeing previous list\n");*/
	  daVarFreeList(result.NAMELIST_val);
	}
	daVarList(*argp,&list,&count); /* Check error code */
	result.NAMELIST_len = count;
	result.NAMELIST_val = list;

	return(&result);
}

NAMELIST * 
davar_getlist_1_svc(char **argp, struct svc_req *svc)
{
	CLIENT *clnt;
	return(davar_getlist_1(argp,clnt));
}


RVALLIST *davar_readmultiple_1(NAMELIST *argp, CLIENT *clnt)
{
  static RVALLIST result;
  int i;
  static int need_to_free=0;

/*  minfo = mallinfo();
  printf("AA:%d %d\n",minfo.arena,minfo.ordblks);*/
  if(need_to_free) {
#ifdef xdr_on_hp_is_broken
    for(i=0; i<result.RVALLIST_len; i++){
      free(result.RVALLIST_val[i].any_u.i.i_val);
    }
    free(result.RVALLIST_val);
#else
    xdr_free(xdr_RVALLIST, (void *) &result);
#endif
  } else need_to_free = 1;
/*  minfo = mallinfo();
  printf("BB:%d %d\n",minfo.arena,minfo.ordblks);*/

  result.RVALLIST_len = argp->NAMELIST_len;
  result.RVALLIST_val = (any *) malloc(result.RVALLIST_len*sizeof(any));

  for(i=0; i<argp->NAMELIST_len; i++){
    daVarReadVar(argp->NAMELIST_val[i],&(result.RVALLIST_val[i]));
  }
  return(&result);
}    

RVALLIST *davar_readmultiple_1_svc(NAMELIST *argp, struct svc_req *svc)
{
	CLIENT *clnt;
	return(davar_readmultiple_1(argp,clnt));
}

ERRLIST *davar_writemultiple_1(WVALLIST *argp, CLIENT *clnt)
{
  static ERRLIST result;
  int i;

  xdr_free(xdr_ERRLIST, (void *) &result);

  result.ERRLIST_len = argp->WVALLIST_len;
  result.ERRLIST_val = (int *) malloc(result.ERRLIST_len*sizeof(any));

  for(i=0; i<argp->WVALLIST_len; i++){
    result.ERRLIST_val[i] =
      daVarWriteVar(argp->WVALLIST_val[i].name,argp->WVALLIST_val[i].val);
  }
  return(&result);
}    

ERRLIST *davar_writemultiple_1_svc(WVALLIST *argp, struct svc_req *svc) 
{
	CLIENT *clnt;
	return(davar_writemultiple_1(argp,clnt));
}

daVarCallBackList *thCallBackListP=0;

int *davar_readmultiple_test_1(TESTNAMELIST *argp, CLIENT *clnt)
{				/* Code fragment to get client info */
  static int result;
  int i;
  daVarCallBackList *next,*this;

  TESTNAMELIST *argcopy;

  SVCXPRT *transp;
  struct sockaddr_in *sock,*sockcopy;
 
/*  printf("IN davar_readmultiple_test_1\n");*/
  sock = (struct sockaddr_in *)
    svc_getcaller(((struct svc_req *) clnt)->rq_xprt);

  /* Copy the arguments */
  argcopy = (TESTNAMELIST *) malloc(sizeof(TESTNAMELIST));
  argcopy->test_condition = (char *) malloc(strlen(argp->test_condition)+1);
  strcpy(argcopy->test_condition, argp->test_condition);
  argcopy->max_time_wait = argp->max_time_wait;
  argcopy->max_event_wait = argp->max_event_wait;
  argcopy->prog = argp->prog;
  argcopy->vers = argp->vers;
  argcopy->NAMELISTP = (NAMELIST *) malloc(sizeof(NAMELIST));
  argcopy->NAMELISTP->NAMELIST_len = argp->NAMELISTP->NAMELIST_len;
  argcopy->NAMELISTP->NAMELIST_val =
    (char **) malloc(argp->NAMELISTP->NAMELIST_len*sizeof(char *));
  for(i=0; i<argp->NAMELISTP->NAMELIST_len; i++){
    argcopy->NAMELISTP->NAMELIST_val[i] = (char *)
      malloc(strlen(argp->NAMELISTP->NAMELIST_val[i])+1);
    strcpy(argcopy->NAMELISTP->NAMELIST_val[i]
            ,argp->NAMELISTP->NAMELIST_val[i]);
  }
  /* Copy the socket */
  sockcopy = (struct sockaddr_in *) malloc(sizeof(struct sockaddr_in));
  bzero(sockcopy,sizeof(struct sockaddr_in));
  bcopy(sock,sockcopy,sizeof(struct sockaddr_in));
  
/*  printf("Socket copied\n");*/
  next = thCallBackListP;
  this = thCallBackListP = (daVarCallBackList *)
    malloc(sizeof(daVarCallBackList));
  this->sock_in = sockcopy;         /* Actually need to copy structure */
  this->list = argcopy;
  this->start_time = time(0);	/* Record when request came in */
  this->next = next;

  
#if 0
  hp = (struct hostent *)
    gethostbyaddr((char *)&sockcopy->sin_addr, sizeof(sockcopy->sin_addr),AF_INET);
  printf("%s %s\n", inet_ntoa(sockcopy->sin_addr), hp->h_name);
#endif

  result = S_SUCCESS;
  return(&result);
}

int *davar_readmultiple_test_1_svc(TESTNAMELIST *argp, struct svc_req *svc)
{			
	CLIENT *clnt;
	return(davar_readmultiple_test_1(argp,clnt));
}
	
int *
davar_readmultiple_test_cb_1(argp, clnt)
	RVALLIST *argp;
	CLIENT *clnt;
{
	static int clnt_res;
	enum clnt_stat clnt_stat;

#if 0
	{
	  struct sockaddr_in sock;
	  struct hostent *hp;
 
	  clnt_control(clnt, CLGET_SERVER_ADDR, (char *) &sock);
	  hp = (struct hostent *)
	    gethostbyaddr((char *)&sock.sin_addr, sizeof(sock.sin_addr),AF_INET);
	  printf("cb_1:  %s %s\n", inet_ntoa(sock.sin_addr), hp->h_name);
	}
#endif

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ((clnt_stat = clnt_call(clnt, DAVAR_READMULTIPLE_TEST_CB, xdr_RVALLIST, argp, xdr_int, &clnt_res, TIMEOUT)) != RPC_SUCCESS) {
	  printf("clnt call failed, clnt_stat = %d\n",clnt_stat);
	  clnt_perrno(clnt_stat);
		return (NULL);
	}
	return (&clnt_res);
}

int *davar_readmultiple_test_cb_1_svc(RVALLIST *argp, struct svc_req *svc)
{			
	CLIENT *clnt;
	return(davar_readmultiple_test_cb_1(argp,clnt));
}

WVALLIST *davar_readpatternmatch_1(char **argp, CLIENT *clnt)
{
  static WVALLIST result;
  int i;
  static int need_to_free=0;
  char *pattern;
  char **vlist;
  int count;

/*  minfo = mallinfo();
  printf("AA:%d %d\n",minfo.arena,minfo.ordblks);*/
  /*  printf("In davar_readpatternmatch_1 doing pattern '%s'\n",*argp);*/
  if(need_to_free) {
#ifdef xdr_on_hp_is_broken
    for(i=0; i<result.WVALLIST_len; i++){
      free(result.WVALLIST_val[i].val->any_u.i.i_val);
      free(result.WVALLIST_val[i].name);
    }
    free(result.WVALLIST_val);
#else
    xdr_free(xdr_WVALLIST, (void *) &result);
#endif
  } else need_to_free = 1;
/*  minfo = mallinfo();
  printf("BB:%d %d\n",minfo.arena,minfo.ordblks);*/

  daVarList(*argp,&vlist,&count);

  result.WVALLIST_len = count;
  result.WVALLIST_val = (wany *) malloc(count*sizeof(wany));

  for(i=0; i<count; i++){
    /*    printf("%d: %s\n",i,vlist[i]);*/
    result.WVALLIST_val[i].name = (char *) malloc(strlen(vlist[i])+1);
    strcpy(result.WVALLIST_val[i].name,vlist[i]);
    /*    daVarReadVar(vlist[i],&(result.WVALLIST_val[i].val));*/
    result.WVALLIST_val[i].val = malloc(sizeof(any));
    daVarReadVar(vlist[i],result.WVALLIST_val[i].val);
  }
  /*  daVarFreeList(vlist);*/
  return(&result);
}    

WVALLIST *davar_readpatternmatch_1_svc(char **argp, struct svc_req *svc)
{
	CLIENT *clnt;
	return(davar_readpatternmatch_1(argp,clnt));
}

int daVarCallBack()
/* Scan the list of pending readmultiple requests.  Make a call back for
   each request for which the test is true or blank.  Ignore the time
   out stuff for now. */
{
  daVarCallBackList *this,*next,**last;
  TESTNAMELIST *argp;
  struct sockaddr_in *sock_in;
  struct hostent *hp;
  DAINT itest;
  static RVALLIST rpc;
  CLIENT *clnt;
  int i;
  int *status;
  int pending,processed;
  int testresult,timeout;

  this = thCallBackListP;
  last = &thCallBackListP;
  pending = 0;
  processed = 0;

  while(this) {
    argp = this->list;
    argp->max_event_wait--;
    testresult = (argp->test_condition == 0 ||
       argp->test_condition[0] == '\0' ||
       (thEvalImed(argp->test_condition,0,&itest),itest));
    timeout = (argp->max_event_wait < 0 
      || (time(0)-this->start_time) > argp->max_time_wait);
    if(testresult || timeout) {
      sock_in = this->sock_in;
/*      printf("PORT=%d,%x\n",sock_in->sin_port,htonl(sock_in->sin_addr.s_addr));*/
      hp = (struct hostent *)
        gethostbyaddr((char *)&sock_in->sin_addr, sizeof(sock_in->sin_addr)
                      ,AF_INET);
/*      printf("Creating client for %s(%x %x)\n",hp->h_name
             ,argp->prog,argp->vers);*/
      if(testresult) {
        /* Build the structure with the return data */
        rpc.RVALLIST_len = argp->NAMELISTP->NAMELIST_len;
        rpc.RVALLIST_val = (any *) malloc(rpc.RVALLIST_len*sizeof(any));

        for(i=0; i<argp->NAMELISTP->NAMELIST_len; i++){
          daVarReadVar(argp->NAMELISTP->NAMELIST_val[i],
                       &(rpc.RVALLIST_val[i]));
        }
      } else {
        rpc.RVALLIST_len = 0;
        rpc.RVALLIST_val = 0;
      }
      {
	/* This is really weird.  clnt_create only works if we copy the hostname*/
	char *host;
	host = malloc(strlen(hp->h_name)+1);
	strcpy(host,hp->h_name);
	clnt = clnt_create(host, argp->prog, argp->vers, "tcp");
	free(host);
      }
      {
	/* This is really weird.  On the alpha it seems we need to copy the
	   host name to a separate variable.  Maybe clnt_create calls some
	   function that mucks with the hp structure. */
	char *host;
	host = malloc(strlen(hp->h_name)+1);
	strcpy(host,hp->h_name);
	clnt = clnt_create(host, argp->prog, argp->vers, "tcp");
	if(clnt) {
	  status = davar_readmultiple_test_cb_1(&rpc, clnt);
	  clnt_destroy(clnt);
	  /* We don't care what the status was. */
	} else {
	  fprintf(stderr,"Callback to %s failed\n",host);
	}
	free(host);
      }
#ifdef xdr_on_hp_is_broken
      if(testresult) {
        for(i=0; i<argp->NAMELISTP->NAMELIST_len; i++){
          free(rpc.RVALLIST_val[i].any_u.i.i_val);
        }
        free(rpc.RVALLIST_val);
      }
      for(i=0; i<argp->NAMELISTP->NAMELIST_len;i++){
        free(argp->NAMELISTP->NAMELIST_val[i]);
      }
      free(argp->NAMELISTP->NAMELIST_val);
      free(argp->NAMELISTP);
      free(argp->test_condition);
#else
      if(testresult) {
	xdr_free(xdr_RVALLIST, (void *) &rpc);
      }
      xdr_free(xdr_TESTNAMELIST, (void *) argp);
#endif
      free(argp);
      free(this->sock_in);
      next = this->next;
      *last = next;
      free(this);
      this = next;
      processed++;
    } else {
      last = &(this->next);
      this = this->next;
      pending++;
    }
  }
  if(processed&&pending==0) return(-1);
  else return(pending);
}
